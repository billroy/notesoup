/*****
	Note Soup server for node.js / redis
	
	Copyright 2011-2012 by Bill Roy.

	Redistribution and use in source and binary forms, with or without modification, 
	are permitted provided that the following conditions are met:
	
		-	Redistributions of source code must retain the above copyright notice, 
			this list of conditions and the following disclaimer.
		-	Redistributions in binary form must reproduce the above copyright notice, 
			this list of conditions and the following disclaimer in the documentation 
			and/or other materials provided with the distribution.
		-	Neither the name of the authors nor the names of its contributors may be
			used to endorse or promote products derived from this software without 
			specific prior written permission.
	
	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
	CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
	PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
	LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*****/

/*****
Redis Database use:

	hash: user/<user>
		field: password
		value: sha-1 of password

	hash: fldr/<user>/<folder>
		fields: [readers, senders, editors]
		value: Access Control List per permission
	
	hash: notes/<user>/<folder>
		field: note.id
		value: json representation of note data
	
	sorted set: mtime/<user>/<folder>
		score: note update time from new Date().getTime()
		id: note.id
	
	integer: stats/notes_created
		unique id generator for noteids; by which function it also counts notes created
		note ids are unique across the soup

	integer: stats/db_created	
		db creation time
		if this is not set, the database autosetup is run

Keys are generated by key_foo functions, e.g., self.key_nextid() or key_usermeta(user)
A search on 'key_' will therefore show all database use.

*****/

var fs = require('fs');
var crypto = require('crypto');
var util = require('util');
var async = require('async');
var rl = require('readline');
var fs = require('fs');
var url = require('url');
var http = require('http');


var NoteSoup = {

// Server configuration
//
opensignup: true,		// when true, anyone, not just 'system', can add a user
enablepush: true,		// true to enable the interworkspace transporter

/***
locked:		false,		// true to disable all access to the soup
wideopen:	false,		// true to disable all access control
***/

connect: function(redis_url) {
	var self = this;

	// handle command line options
	if (self.argv.nopush) self.enablepush = false;
	if (self.argv.nosignup) self.opensignup = false;

	if (process.env.nopush) self.enablepush = false;
	if (process.env.nosignup == 'true') self.opensignup = false;

	if (redis_url) {
		self.log("Connecting to Redis at " + redis_url);
		self.redis = require('redis-url').connect(redis_url);
	}
	else {
		self.log("Connecting to local Redis");
		self.redis = require("redis").createClient();		// port, host, options
	}
	
	self.redis.on("error", function (err) {
		console.error("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$");
		console.error("Redis Error: " + err);
		console.error("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$");
	});

	self.initdatabase();

	// init socket.io
	if (self.enablepush) {
		self.io = require('socket.io').listen(self.app);
		self.io.sockets.on('connection', function(socket) {
			self.log('Socket connection accepted.');
			//self.log(util.inspect(socket, 3));
			socket.on('subscribe', function(request) {
				self.log('Subscription request:', request);
				socket.on(request.channel, function(msg) {
					self.io.sockets.emit(request.channel, msg);
				});

				if (request.channel.split('/')[1] == 'folder') {
					socket.on('disconnect', function() {
						// onleave
						var msg = {
							method: 'notify',
							sender: self.systemuser,
							channel: request.channel,
							op: 'say',
							data: '' + request.sender + ' has left.'
						};
						self.io.sockets.emit(request.channel, msg);
					});
	
					// onjoin
					var msg = {
						method: 'notify',
						sender: self.systemuser,
						channel: request.channel,
						op: 'say',
						data: '' + request.sender + ' has joined.'
					};
					self.io.sockets.emit(request.channel, msg);
				}
			});
		});
	}

	return self;
},

status: function(req, res) {
	var self = this;
	if (!self.isroot(req, res)) res.send("OK");
	else {
		self.redis.info(function(err, reply) {
			self.log('Status:', reply);
			var lines = reply.split('\r\n');
			self.dir(lines);
			var dict = {};
			for (var i=0; i < lines.length; i++) {
				var parts = lines[i].split(':');
				if (parts[0]) dict[parts[0]] = parts[1];
			}
			//res.contentType("text/plain");
			//res.send(util.inspect(dict));
			res.send(JSON.stringify(dict));
		});
	}
},

templatecache: {},

fetchtemplate: function(templatename) {
	var self = this;
	if (!self.templatecache.hasOwnProperty(templatename)) {
		self.templatecache[templatename] = fs.readFileSync(__dirname + '/templates/' + templatename, 'utf-8');
	}
	return self.templatecache[templatename];
},

renderfolder: function(req, res, template) {
	var self = NoteSoup;
	req.starttime = new Date().getTime();
	req.template = template;

	self.log('***********************************');
	self.log('rendering folder ' + req.params.user + ' ' + req.params.folder);
	self.log('***********************************');

	if (self.locked && !self.isroot(req, res)) {
		res.redirect('Service unavailable.  Please try again later.', 503);
		return;
	}

	// marshall like an api call so we can use the API's ACL-check pipeline handlers
	req.body.method = 'openfolder';
	if (!req.body.params) req.body.params = {};
	req.body.params.fromfolder = req.params.user + '/' + req.params.folder;
	res.updatelist = [];
	req.starttime = new Date().getTime();
	async.series([
		function(next) {self.loadfromacl(req, res, next);}, 
		function(next) {self.validateaccess(req, res, next);},
		function(next) {self.preloadnotes(req, res, next);},
		function(next) {self.sendpage(req, res, next);},
	],
	function(err, reply) {
		if (err) res.redirect('/folder/system/accesserror');
	});
},

preloadnotes: function(req, res, next) {
	var self = NoteSoup;
	var updatetime = new Date().getTime();
	self.redis.hgetall(self.key_note(req.body.params.fromfolder), function(err, notes) {
		if (err) {
			next(err);
			return;
		}
		res.initnotes = [];
		for (var id in notes) {
			var thenote = JSON.parse(notes[id]);
			if (thenote.hasOwnProperty('text')) {
				thenote.text = thenote.text.replace(/</g, '&lt;');
			}
			res.initnotes.push(thenote);
		}
		if (res.initnotes.length) res.lastupdate = updatetime;
		//self.log('preload:', res.initnotes);

		next(null);
	});
},

sendpage: function(req, res, next) {
	var self = NoteSoup;

	// provision the client options	
	// TODO: hook up real ACL
	var opts = {
		loggedin:	req.session.loggedin || false,
		username:	req.session.username || 'guest',
		foldername:	req.params.user + '/' + req.params.folder
		//isowner:	req.session.loggedin && (req.session.username == req.params.user)
	};
	opts.ispublic = self.hasaccess(req, res, '*', opts.foldername, self.readers);
	opts.iseditor = self.hasaccess(req, res, self.effectiveuser(req, res), opts.foldername, self.editors);
	if (req.acl[opts.foldername].hasOwnProperty(self.key_folderbackground())) {
		opts[self.key_folderbackground()] = req.acl[opts.foldername][self.key_folderbackground()]
	}

	if (res.initnotes.length > 0) {
		opts.initnotes = res.initnotes;
		opts.lastupdate = res.lastupdate;
	}

	// render index.html as a template with these options
	var page = self.fetchtemplate(req.template);
	var string_opts = util.inspect(opts);

	//self.log('Rendering options:');
	//self.log(string_opts);

	res.send(page.replace('\'{0}\'', string_opts));
	self.logdt(req, res);
	next(null);
},


NEXT_NOREPLY: "NEXT_NOREPLY",	// in api_ functions, next(NEXT_NOREPLY) prevents senderror/send/reply

dispatch: function(req, res) {
	var self = this;
	res.updatelist = [];
	req.starttime = new Date().getTime();
	
	self.log('***********************************');
	self.log('api request: ', req.body.method);
	self.log('***********************************');
	self.log('params: ', req.body.params);

	async.series([
		function(next) {self.validatemethod(req, res, next);}, 
		function(next) {self.loadfromacl(req, res, next);}, 
		function(next) {self.loadtoacl(req, res, next);}, 
		function(next) {self.validateaccess(req, res, next);}, 
		function(next) {self.execute(req, res, next);}
	],
	function(err, reply) {
		if (err && (err != self.NEXT_NOREPLY)) self.senderror(req, res, err);
		else self.sendreply(req, res);
	});
},

validatemethod: function(req, res, next) {
	var self = NoteSoup;
	if (typeof(self['api_' + req.body.method]) != 'function') {
		self.log('No method for request:', req.body);
		next('The server does not know how to ' + req.body.method);
	}
	else if (!req.body.method in self.acl_checklist) {
		self.log('No acl for method: ' + req.body.method);
		//next('ACL error');
	}
	next(null);
},

loadfromacl: function(req, res, next) {
	var self = NoteSoup;
	self.loadfolderacl(req, res, 'fromfolder', next);
},

loadtoacl: function(req, res, next) {
	var self = NoteSoup;
	self.loadfolderacl(req, res, 'tofolder', next);
},

loadfolderacl: function(req, res, fieldname, next) {
	var self = NoteSoup;
	if (!req.acl) req.acl = {};

	//self.log('loadfolderacl: ' + fieldname + ' ' + req.body.params[fieldname], req.body.params);

	if (typeof(req.body.params[fieldname]) == 'undefined') {
		//self.log('no arg ' + fieldname);
		next(null);
		return;
	}

	var folder = req.body.params[fieldname];	// fetch fromfolder or tofolder
	
	//self.log('Loadfolderacl: ' + fieldname + ' ' + folder);

	if (!self.isvalidfoldername(folder)) {
		next('Invalid folder name.');
	}
	else if (folder in req.acl) next(null);	// if we already have it, don't reread it
	else if (folder) {
		self.redis.hgetall(self.key_foldermeta(folder), function(err, folderdata) {
			if (err) {
				self.log('Error fetching folder acl: ' + folder);
				next('Error fetching folder acl.');
				return;
			}
			req.acl[folder] = folderdata;
			self.log('loadfolderacl:', req.acl);
			next(null);
		});
	}
	else next(null);
},

validateaccess: function(req, res, next) {
	var self = NoteSoup;

	if (self.wideopen) {
		next(null, 'Everybody has root!');
		return;
	}
	if (self.locked) {
		next('System locked.');
		return;
	}

	var aclcheck = self.acl_checklist[req.body.method];
	if (!aclcheck) {
		self.log('note: no acl check for api: ' + req.body.method);
		next(null);		// 'No acl check string?!');
		return;
	}

	while (aclcheck.length) {

		// determine the level of access required for the function
		var accessmode;
		if (aclcheck[1] == 'o') accessmode = self.owners;
		else if (aclcheck[1] == 'e') accessmode = self.editors;
		else if (aclcheck[1] == 's') accessmode = self.senders;
		else accessmode = self.readers;

		// now determine whether we're checking tofolder or fromfolder
		var folder;
		if (aclcheck[0] == 't') folder = req.body.params.tofolder;
		else if (aclcheck[0] == 'f') folder = req.body.params.fromfolder;
		else next('bad acl spec');

		//self.log('validateaccess: folder ' + folder + ' ' + accessmode);

		aclcheck = aclcheck.substring(2);	// prune off what we handled

		if (!self.hasaccess(req, res, self.effectiveuser(req, res), folder, accessmode)) {
			self.log('Access denied.');
			next("Access denied.");
			return;
		}
	}
	//self.log('Access granted.');
	next(null);
},

execute: function(req, res, next) {
	NoteSoup['api_' + req.body.method](req, res, next);
},


// Encoded folder access requirements for command ACL checks
//
// ts: tofolder requires sender permission or better
// fr: fromfolder requires reader
// to: tofolder requires owner
//
acl_checklist: {
	'savenote': 		'ts',
	'appendtonote': 	'ts',		// should be editors?  or is this a hack?
	'sendnote': 		'tsfr',		// ts+deleteoriginal ? fe : fr, the api upgrades
	'getnote': 			'fr',
	'getfolder': 		'fr',
	'openfolder': 		'fr',
	'sync': 			'fr',
	'gettemplatelist': 	'fr',
	'getnotes': 		'fr',
	'createfolder':		'to',
	'deletefolder': 	'fo',
	'copyfolder': 		'frts',		// +destination folder create is required ? to : ts
	'getfolderacl': 	'to',
	'setfolderacl': 	'to',
	'setfolderbackground': 'to'
},


// test for characters invalid in user and folder names
invalidchars: /[^A-z0-9\-._]/g,

isvalidfoldername: function(foldername) {
	var self = NoteSoup;
	var parts = foldername.split('/');
	if (parts.length != 2) return false;
	if (self.invalidchars.test(parts[0])) return false;
	if (self.invalidchars.test(parts[1])) return false;
	return true;
},

getuserpart: function(folder) {
	return folder.split('/')[0];
},

readers: 'readers',
editors: 'editors',
senders: 'senders',
owners: 'owners',


hasaccess: function (req, res, requestor, tofolder, accessmode) {
	var self = this;
	//self.log('hasaccess: requestor ' + requestor);
	//self.log('hasaccess: tofolder ' + tofolder);
	//self.log('hasaccess: accessmode ' + accessmode);
	var result = self.getaccess(req, res, requestor, tofolder, accessmode);

	// read and append inherit from edit so appeal a "no" to the higher priv
	if (!result && ((accessmode == this.readers) || (accessmode == this.senders))) {
		result = self.getaccess(req, res, requestor, tofolder, this.editors);
	}
	self.log("hasAccess: " + requestor + ' ' + tofolder + ' ' + accessmode + ' ' + result);
	return result;
},

getaccess: function(req, res, requestor, tofolder, accessmode) {
	var self = this;
	if (!self.isvalidfoldername(tofolder)) return false;
	
	// TODO: Can't access non-existent user/folder
	
	// A user has full access to her own folders...
	// ...as does the systemuser
	var owner = self.getuserpart(tofolder);
	//self.log('owner ' + owner + ' requestor ' + requestor);
	if ((requestor == owner) || (requestor == self.systemuser)) {
		return true;
	}

	// Accessing another user's data - check the permissions
	//accessstring = self.getAccess(tofolder, accessmode)
	if (!req.acl[tofolder]) {
		self.log('getaccess: folder not in acl cache: ' + tofolder);
		return false;
	}

	var accessstring = req.acl[tofolder][accessmode];	// get access string from acl{}
	if (!accessstring) accessstring = '';	// act like -*, deny below
	accessstring = accessstring.trim();
	//self.log('getaccess: ' + accessmode + ' [' + accessstring + ']');

	// TODO: regexp matching for domain-based group permissions like *.example.com
	// For now, *, -* and username, -username, separated by commas
	// -@ means "anyone but guest"
	var access = false;
	var specifiers = accessstring.split(',');
	for (var i=0; i < specifiers.length; i++) {
		var a = specifiers[i];
		//self.log('access string frag: ' + a);
		if (a == '') continue;		// skip empty/null items
		if (a[0] == '-') {			// Process DENY items
			if (a.length < 2) break;	// naked '-'
			var denied = a.substr(1);
			if ((denied == '*') || (denied == requestor)) break;	// deny
			if (denied == '@') {									// deny guest
				access = (requestor == self.guestuser);
				break;
			}
		}
		else if ((a == '*') || (a == requestor)) {
			access = true;		// allow
			break;
		}
		else if (a == '@') {
			access = (requestor != self.guestuser);		// allow non-guest
			break;
		}
	}
	return access;
},

systemuser: 'system',
guestuser: 'guest',

// Redis key mapping
//
key_note: function(folder) 		{ return 'notes/' + folder; },
key_mtime: function(folder) 	{ return 'mtime/' + folder; },
//key_nextid:  function(folder)	{ return 'next/'  + folder; },
key_nextid:  function(folder)	{ return 'stats/notes_created'; },

log: function() {
	var output = [];
	for (var i=0; i < arguments.length; i++) {
		if (typeof(arguments[i]) == 'object') {
			output.push(util.inspect(arguments[i], false, 6));
		}
		else output.push('' + arguments[i]);
	}
	console.log(output.join(' '));
},

dir: function(thing) {
	console.log(util.inspect(thing, false, 5, true));
},

logdt: function(req, res) {
	var self = NoteSoup;
	req.endtime = new Date().getTime();
	req.time = req.endtime - req.starttime;
	self.log('dt=' + req.time + 'ms');
},

senderror: function(req, res, errormessage) {
	var reply = {
		result: '',
		error: errormessage,
		id: req.body.id,
		command: []		
	};
	res.send(reply);

	this.log('Error:', reply);
	console.error('Error:', reply);
	this.logdt(req, res);
},

sendreply: function(req, res) {
	var self = this;
	var reply = {
		result: '',
		error: null,
		id: req.body.id,
		command: res.updatelist
	};
	res.send(reply);

	self.log('Reply:', reply);
	self.logdt(req, res);

	var notifyfolder = req.body.params.notifyfolder || req.body.params.tofolder || req.body.params.fromfolder;
	if (notifyfolder) {
		for (var i=0; i < res.updatelist.length; i++) {
			var cmd = res.updatelist[i][0];
			if ((cmd == 'updatenote') || (cmd == 'deletenote') || (cmd == 'setbackground')) {
				self.notifychange(req, res, notifyfolder, res.updatelist[i]);
			}
		}
	}
},

api_savenote: function(req, res, next) {
	var self = this;

	// convert a single note to an array for the forEach construct
	if (typeof(req.body.params.note[0]) == 'undefined') {	// a single note, not an array
		req.body.params.note = [req.body.params.note];
	}
	// todo: test this without Series
	async.forEachSeries(req.body.params.note,
		function(note, next) {
			req.body.params.thenote = note;
			async.series([
				function(next) {self.checkid(req, res, next);}, 
				function(next) {self.savenote(req, res, next);}
			], 
			function(err, reply) {
				next(err);
			});
		},
		function(err, reply) { next(err); }
	);
},

checkid: function(req, res, next) {
	var self = NoteSoup;

	//self.log('Checkid: this', this);
	
	self.log('Checkid: params', req.body.params);	

	if (!req.body.params.thenote.id) {
		self.redis.incr(self.key_nextid(req.body.params.tofolder), function(err, id) {
			if (err) next(err);
			req.body.params.thenote.id = id.toString();
			next(null, 1);
		});
	}
	else next(null, 2);
	//self.log('Leaving checkid');
},

addupdate: function(req, res, update) {
	var self = this;
	self.log('addupdate:', update);
	res.updatelist.push(update);
	//self.notifychange(req.body.params.tofolder, update);
},

savenote: function(req, res, next) {
	var self = NoteSoup;
	var now = new Date().getTime();
	var jsonnote = JSON.stringify(req.body.params.thenote);

	self.log('Savenote: params', req.body.params);

	if (!req.body.params.thenote.id) {
		self.log('savenote without id');
		next(null, 3);
		return;
	}

	var update = ['updatenote', req.body.params.thenote];
	self.addupdate(req, res, update);
	self.notifychange(req, res, req.body.params.tofolder, update);

	self.redis.multi()
		.hset(self.key_note(req.body.params.tofolder), req.body.params.thenote.id, jsonnote)
		.zadd(self.key_mtime(req.body.params.tofolder), now, req.body.params.thenote.id)
	 	.exec(function (err, replies) {
			self.log("SaveNote got " + replies.length + " replies");
			replies.forEach(function (reply, index) {
				self.log("Reply " + index + ": " + reply.toString());

			});
			next(null, 4);
		});
	self.log('Leaving savenote');
},

notifychange: function(req, res, tofolder, update) {
	var self = this;
	self.log('Notify:', tofolder, update);
	var channel = '/folder/' + tofolder;
	var msg = {
		method: 'notify',
		sender: self.effectiveuser(req, res),
		channel: channel,
		op: update[0],
		data: update[1]
	};
	self.io.sockets.emit(channel, msg);
},

api_appendtonote: function(req, res, next) {
	var self = this;
	self.redis.hget(self.key_note(req.body.params.tofolder), 
		req.body.params.noteid, function(err, notetext) {

		if (err) next(err);
		else if (!notetext) next('Note?');
		else {
			var note = JSON.parse(notetext);
			self.log('Append: note ', typeof(note), note);

			if (note.text) note.text = note.text + req.body.params.text;
			else note.text = req.body.params.text;
			
			req.body.params.note = note;
			self.api_savenote(req, res, next);
		}
	});
},

api_sync: function(req, res, next) {
	var self = this;
	newlastupdate = new Date().getTime().toString();
	//self.log('Last sync: ' + req.body.params.lastupdate);
	//self.log('Sync mark: ' + newlastupdate);

	if (req.body.params.lastupdate == 0) {
		self.redis.hgetall(self.key_note(req.body.params.fromfolder), function(err, notes) {
			if (err) {
				next(err);
				return;
			}
			self.log('First sync:', notes);
			self.addupdate(req, res, ['beginupdate','']);
			for (var id in notes) {
				var note = JSON.parse(notes[id]);
				self.addupdate(req, res, ['updatenote', note]);
			}
			self.addupdate(req, res, ['endupdate','']);
			self.addupdate(req, res, ['setupdatetime', newlastupdate]);
			next(null);
		});
	}
	else {
		self.redis.zrangebyscore(self.key_mtime(req.body.params.fromfolder), 
			req.body.params.lastupdate, '+inf', function(err, noteids) {
				if (err) {
					next(err);
					return;
				}
				if (!noteids.length) {
					self.addupdate(req, res, ['setupdatetime', newlastupdate]);
					next(null);
					return;
				}
				self.redis.hmget(self.key_note(req.body.params.fromfolder), noteids, function(err, notes) {
					if (err) {
						next(err);
						return;
					}
					self.log('Syncing updated notes:', notes);
					if (notes) {
						self.addupdate(req, res, ['beginupdate','']);
						for (var i=0; i<notes.length; i++) {
							var note = JSON.parse(notes[i]);
							self.addupdate(req, res, ['updatenote', note]);
						}
						self.addupdate(req, res, ['endupdate','']);
					}
					self.addupdate(req, res, ['setupdatetime', newlastupdate]);
					next(null);
				});
		});
	}
},

api_sendnote: function(req, res, next) {
	var self = this;

	// if a single id was passed in, coerce it to a list
	if (typeof(req.body.params.noteid) == 'string')
		req.body.params.noteid = [req.body.params.noteid];

	async.forEachSeries(req.body.params.noteid,
		function(noteid, next) {
			self.sendnote(req, res, noteid, 
			function(err, reply) {
				next(err);
			});
		}, 
		function(err, reply) { next(err); }
	);
},

sendnote: function(req, res, noteid, next) {
	var self = NoteSoup;
	self.redis.multi()
		.hget(self.key_note(req.body.params.fromfolder), noteid)
		.incr(self.key_nextid(req.body.params.tofolder))
		.exec(function(err, reply) {

			if (err) {
				next(err);
				return;
			}

			var note = JSON.parse(reply[0]);
			self.log('Fetched note: ' + typeof(note), note);
			note.id = reply[1].toString();
			self.log('New note id: ' + note.id);
			var now = new Date().getTime();

			self.redis.multi()
				.hset(self.key_note(req.body.params.tofolder), note.id, JSON.stringify(note))
				.zadd(self.key_mtime(req.body.params.tofolder), now, note.id)
				.exec(function(err, reply) {

					if (err) {
						next(err);
						return;
					}

					if (req.body.params.tofolder == req.body.params.notifyfolder)
						self.addupdate(req, res, ['updatenote', note]);

					if (!('deleteoriginal' in req.body.params) || req.body.params.deleteoriginal) {
						self.redis.multi()
							.hdel(self.key_note(req.body.params.fromfolder), noteid)
							.zrem(self.key_mtime(req.body.params.fromfolder), noteid)
							.exec(function(err, reply) {
								if (err) {
									next(err);
									return;
								}

								if (req.body.params.fromfolder == req.body.params.notifyfolder)
									self.addupdate(req, res, ['deletenote', noteid]);
								next(null);
							});
					}
					else next(null);
				});
		});
},

api_postevent: function(req, res, next) {
	var self = this;
	self.log('PostEvent via api: (DROPPED)');
	//io.socket.send(res.body.params.
	//self.addupdate(req, res, ['say', 'PostEvent was dropped.']);
	next(null);
},

getTemplates: function(req, res, folder, next) {
	var self = this;
	self.redis.hgetall(self.key_note(folder), function(err, jsonnotes) {

		if (err) {
			next(err);
			return;
		}
	
		if (!jsonnotes) {
			next('no notes');
			return;
		}
		for (var n in jsonnotes) {
			var note = JSON.parse(jsonnotes[n]);
			res.templatelist.push([folder, note, note.notename || 'untitled']);
		}
		// sort by item[2], the notename
		res.templatelist.sort(function(a,b) {
			if (a[2] > b[2]) return 1;
			if (a[2] == b[2]) return 0;
			if (a[2] < b[2]) return -1;
		});
		next(null);
	});
},

templatefolder: 'templates',

api_gettemplatelist: function(req, res, next) {
	var self = this;
	res.templatelist = [];

	// the portable hole uses the fromfolder form
	if (!req.body.params.includesystemtemplates) {
		self.getTemplates(req, res, req.body.params.fromfolder, function() {
			self.addupdate(req, res, ['templatelist', res.templatelist]);
			next(null);
		});
	}

	else self.getTemplates(req, res, self.systemuser + '/' + self.templatefolder, function() {
		self.getTemplates(req, res, self.effectiveuser(req, res) + '/' + self.templatefolder, function() {
			self.addupdate(req, res, ['templatelist', res.templatelist]);
			next(null);
		});
	});
},

api_getnotes: function(req, res, next) {
	var self = this;
	self.redis.hgetall(self.key_note(req.body.params.fromfolder), function(err, jsonnotes) {
		if (err) {
			next(err);
			return;
		}
		else if (jsonnotes) {
			//self.log("Got notes from", req.body.params.fromfolder, json_notes);
			var parsed_notes = {};
			for (var n in jsonnotes) {
				var note = JSON.parse(jsonnotes[n]);
				parsed_notes[note.id] = note;
			}	
			self.addupdate(req, res, ['notes', parsed_notes]);
		}
		next(null);
	});
},

key_folderquery: function(user) {
	return this.key_note(user + '/*');
},

api_getfolderlist: function(req, res, next) {
	var self = this;

	if (!req.session.loggedin) {
		self.addupdate(req, res, ['folderlist', []]);
		next(null);
		return;
	}
	self.redis.keys(self.key_folderquery(self.effectiveuser(req, res)), function(err, keylist) {
		if (err) {
			next(err);
			return;
		}
		if (keylist.length) {
			var folderlist = [];
			for (var i=0; i<keylist.length; i++) folderlist.push(keylist[i].substr(6));
			folderlist.sort();
			self.addupdate(req, res, ['folderlist', folderlist]);
		}
		next(null);
	});
},

api_createfolder: function(req, res, next) {
	var self = this;
	// todo: write the fldr/ hash
	req.body.params.fromfolder = req.body.params.tofolder;
	self.api_openfolder(req, res, next);
},

api_openfolder: function(req, res, next) {
	var self = this;
	res.updatelist.push(['navigateto', '/folder/' + req.body.params.fromfolder]);
	next(null);
},

effectiveuser: function(req, res) {
	var self = NoteSoup;
	return req.session.loggedin ? req.session.username : self.guestuser;
},

isroot: function(req, res) {
	var self = this;
	return (req.session.loggedin && (self.effectiveuser(req, res) === self.systemuser));
},

navigatehome: function(req, res) {
	var self = this;
	if (req.session.loggedin) {
		self.addupdate(req, res, [
			'navigateto', 
			'/folder/' + self.effectiveuser(req, res) + '/' + self.inboxfolder
		]);
	}
	else self.addupdate(req, res, ['navigateto', '/']);
},

deletefolder: function(folder, next) {
	var self = this;
	self.redis.multi()
		.del(self.key_note(folder))
		.del(self.key_mtime(folder))
//		.del(self.key_nextid(folder))
		.del(self.key_foldermeta(folder))
		.exec(function(err, reply) {
			next(err, reply);
		});
},

api_deletefolder: function(req, res, next) {
	var self = this;
	self.deletefolder(req.body.params.fromfolder, function(err, reply) {
		if (err) next(err);
		else {
			self.navigatehome(req, res);
			next(null);
		}
	});
},

api_emptytrash: function(req, res, next) {
	var self = this;
	self.deletefolder(self.effectiveuser(req, res) + '/trash', function(err, reply) {
		if (err) next(err);
		else {
			self.addupdate(req, res, ['say', 'The trash is empty.']);
			next(null);
		}
	});
},


/**
*	return a string of random alphanumeric characters of a specified length
*	@param {int} namelen the length of the string
*/
randomName: function(namelen) {
	var charset = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
	var name = '';
	while (name.length < namelen) 
		name += charset.charAt(Math.floor(Math.random() * charset.length));
	return name;
},

key_usermeta: function(user) {
	return 'user/' + user;
},
passwordattr: 'password',

api_createuser: function(req, res, next) {
	var self = this;
	async.series([
		function(next) {self.checksignup(req, res, next);},
		function(next) {self.validateusername(req, res, next);},
		function(next) {self.failifuserexists(req, res, next);},
		function(next) {self.setpassword(req, res, next);}
	],
	function(err, reply) {
		if (err) next(err);
		else next(null);
	});
},

api_setpassword: function(req, res, next) {
	var self = this;
	if (!req.session.loggedin) {
		next('Log in to set a password.');
		return;
	}
	if ((req.body.params.username != self.effectiveuser(req, res)) && !self.isroot(req, res)) {
		next('Invalid password.');
		return;		
	}

	async.series([
		function(next) {self.validateusername(req, res, next);},
		function(next) {self.ensureuserexists(req, res, next);},
		function(next) {self.setpassword(req, res, next);}
	],
	function(err, reply) {
		next(err);
	});
},

checksignup: function(req, res, next) {
	var self = NoteSoup;
	if (!self.opensignup && !self.isroot(req, res)) {
		next('Signups are closed.  Please contact the system administrator to create a new user.');
	}
	else next(null);
},

validateusername: function(req, res, next) {
	var self = NoteSoup;
	var min_length = 1;
	var max_length = 50;
	if (!req.body.params.username || 
		(req.body.params.username.length < min_length) ||
		(req.body.params.username.length > max_length)) next('Invalid name.');
	if (self.invalidchars.test(req.body.params.username)) next('Invalid character.');
	else next(null);
},

failifuserexists: function(req, res, next) {
	var self = NoteSoup;
	self.redis.hget(self.key_usermeta(req.body.params.username), 
		self.passwordattr, function(err, passwordhash) {
			if (err || passwordhash) next('That name is not available.');
			else next(null);
		});
},

ensureuserexists: function(req, res, next) {
	var self = NoteSoup;
	self.redis.hget(self.key_usermeta(req.body.params.username), 
		self.passwordattr, function(err, passwordhash) {
			if (err || !passwordhash) next('Invalid input.');
			else next(null);
		});
},

setpassword: function(req, res, next) {
	var self = NoteSoup;
	self.savepasswordhash(req.body.params.username, req.body.params.password, 
		function(err, reply) {
			if (err) next(err);
			else {
				// if it's not admin creating a new user we log in and go there
				if (!self.isroot(req, res)) {
					self.initsessiondata(req, res);
					self.navigatehome(req, res);
				}
				self.addupdate(req, res, ['say','Credentials saved.']);
				next(null);
			}
		}
	);
},

inboxfolder: 'inbox',

savepasswordhash: function(user, passwordhash, next) {
	var self = this;
	self.redis.hset(self.key_usermeta(user), 
		self.passwordattr, 
		passwordhash, 
		function(err, reply) {
			if (err) next(err);
			else {
				self.log('Password updated for ', user, reply);
				next(null);
			}
		}
	);
},


key_foldermeta: function(folder) {
	return 'fldr/' + folder;
},

api_getfolderacl: function(req, res, next) {
	var self = this;
	self.redis.hgetall(self.key_foldermeta(req.body.params.tofolder), function(err, acl) {
		if (err) {
			// why doesn't this next(err); ?
			self.log('getfolderacl: error', err);
			next(err);
			return;
		}
		acl.folder = req.body.params.tofolder;
		self.addupdate(req, res, ['folderacl', acl]);
		next(null);
	});
},

api_setfolderacl: function(req, res, next) {
	var self = this;
	var acl = {};
	var fields = ['readers','senders', 'editors', 'password'];
	for (var i=0; i < fields.length; i++) {
		if (req.body.params.hasOwnProperty(fields[i])) {
			acl[fields[i]] = req.body.params[fields[i]];
		}
	}
	self.log("SetACL ", req.body.params.tofolder, acl);

	self.redis.hmset(self.key_foldermeta(req.body.params.tofolder), acl, function(err, reply) {
		if (err) next(err);
		else {
			self.addupdate(req, res, ['say', 'Folder permissions updated.']);
			next(null);
		}
	});
},

key_folderbackground: function() {
	return 'background';
},

api_setfolderbackground: function(req, res, next) {
	var self = this;
	var background = req.body.params.background || '';
	self.log('background:', req.body.params.tofolder, req.body.params.background, background);

	self.redis.hset(
		self.key_foldermeta(req.body.params.tofolder), 
		self.key_folderbackground(),
		background, 
		function(err, reply) {
			if (err) next(err);
			else {
				self.addupdate(req, res, ['setbackground', background]);
				self.addupdate(req, res, ['say', 'Folder background saved.']);
				next(null);
			}
		});
},

api_knockknock: function(req, res, next) {
	var self = this;
	req.session.nonce = self.randomName(32);	// save login nonce
	res.updatelist.push(['whosthere', req.session.nonce]);
	next(null);
},


badlogin: function(req, res, next) {
	var self = this;
	self.clearsessiondata(req, res);
	next('Invalid login.');
},

api_login: function(req, res, next) {
	var self = this;
	self.redis.hget(self.key_usermeta(req.body.params.username), 
		self.passwordattr, function(err, passwordhash) {

		if (err) {
			self.log('Login hget error: ' + err);
			self.badlogin(req, req, next);
			return;
		}

		self.log('login: ' + req.body.params.username);
		//self.dir(passwordhash);

		if (!passwordhash) {
			self.badlogin(req, res, next);
			return;
		}

		var salted_hash = crypto.createHash('sha1')
							.update(passwordhash + req.session.nonce)
							.digest('hex');
		//self.log('Login: saved  hash ' + passwordhash);
		//self.log('Login: saved nonce ' + req.session.nonce);
		//self.log('Login: salted hash ' + salted_hash);
		//self.log('Login: client hash ' + req.body.params.passwordhash);
		if (salted_hash == req.body.params.passwordhash) {
			self.initsessiondata(req, res);
			self.navigatehome(req, res);
			next(null);
		}
		else {
			self.badlogin(req, res, next);
		}
	});
},

initsessiondata: function(req, res) {
	req.session.loggedin = true;
	req.session.username = req.body.params.username;
	delete req.session.nonce;
},

clearsessiondata: function(req, res) {
	var self = this;
	delete req.session.loggedin;
	delete req.session.username;
	delete req.session.nonce;
},

api_logout: function(req, res, next) {
	var self = this;
	self.clearsessiondata(req, res);
	self.addupdate(req, res, ['navigateto', '/']);
	next(null);
},


api_geturl: function(req, res, next) {
	var self = this;
	//self.log('geturl: ' + req.body.params.url);
	var options = url.parse(req.body.params.url);

	// handle local '/path' fetches as static
	if (!options.host) {
		self.log('geturl: serving static ' + options.pathname);
		res.sendfile(__dirname + '/public' + options.pathname);
		self.logdt(req, res);
		return;
	}

	// fetch a remote url
	options.headers = {
		//'Accept': '*/*'
		'Accept': 'application/x-javascript; charset=utf-8'
	};
	options.agent = false;	// prevent Connection-Keepalive in the framework
	res.data = [];
	var httpreq = http.get(options, function(httpres) {
		httpres.on('data', function (chunk) {
			self.log('Geturl body: ' + chunk.length);
			res.data.push(chunk);
		});
		httpres.on('end', function (chunk) {
			self.log('Geturl finishing...');
			res.data.push(chunk);
			res.write(res.data.join(''));
			res.end();
			self.log('Geturl done.');
			self.logdt(req, res);
			next(self.NEXT_NOREPLY);
		});
	}).on('error', function(e) {
		self.log('Geturl error: ' + e.message);
		next('Geturl error: ' + e.message);
	});
},



// File Import

loadfile: function(fromdirectory, filename, tofolder, next) {
	var self = NoteSoup;
	self.log('Loadfile: ' + filename);

	var aclfiles = ['.readers','.editors','.senders'];
	var aclattrs = ['readers','editors','senders'];
	var aclindex = aclfiles.indexOf(filename);
	if (aclindex >= 0) {
		self.log('handling folder attribute file: ' + filename);
		
		var filepath = self.load.fromdirectory + '/' + filename;
		self.log('filepath: ' + filepath);
		var filetext = fs.readFileSync(filepath, 'utf8');		// specifying 'utf8' to get a string result
		filetext = filetext.trim();

		self.redis.hset(self.key_foldermeta(tofolder), aclattrs[aclindex], filetext, 
			function(err, reply) {
				if (err) next(err);
				else {
					self.log('folder attribute set: ' + tofolder + ' ' + aclattrs[aclindex] + ' ' + filetext);
					next(null);
				}
			}
		);
		return;
	}
	else if (filename.charAt(0) == '.') {
		self.log('Skipping unhandled system file ' + filename);
		next(null);
		return;
	}

	var filepath = fromdirectory + '/' + filename;

	self.log('filepath: ' + filepath);

	var filetext = fs.readFileSync(filepath, 'utf8');		// specifying 'utf8' to get a string result

	//self.log('filetext: ' + filetext);
	
	var note = JSON.parse(filetext);

	// Clean up the note a bit
	if (note.bgcolor == '#FFFF99') delete note.bgcolor;
	if (note.bgcolor == '#ffff99') delete note.bgcolor;
	if (note.imports) note.imports = note.imports.replace('http://chowder.notesoup.net', '');
	if (note.backImage) note.backImage = note.backImage.replace('http://notesoup.net', '');

	// Nuke some fields entirely
	var killfields = ['syncme','showme','feedstr','feeddata','from'];
	for (var k in killfields) delete note[k];

	// Map fields to new squeezenote format

	self.redis.incr(self.key_nextid(tofolder), function(err, id) {
		if (err) {
			next(err);
			return;
		}
		note.id = id.toString();
		//note.mtime = new Date().getTime();
		var mtime = new Date().getTime();
		var jsonnote = JSON.stringify(note);

		self.redis.multi() 
			.hset(self.key_note(tofolder), note.id, jsonnote)
			.zadd(self.key_mtime(tofolder), mtime, note.id)
			.exec(function (err, replies) {
				if (err) next(err);
				else next(null);
			});
	});
},

loadfolder: function(foldername, nextfolder) {
	var self = NoteSoup;
	self.log('Loadfolder: fromdirectory: ' + self.load.fromdirectory);
	self.log('Loadfolder: tofolder: ' + self.load.tofolder);

	if (foldername.charAt(0) == '.') {
		self.log('handling system folder/file ' + foldername);
		if (foldername == '.userinfo') {
			self.log('converting password file');
			var filepath = self.load.fromdirectory;		// misnomer, it's the full file path
			self.log('filepath: ' + filepath);
			var filetext = fs.readFileSync(filepath, 'utf8');		// specifying 'utf8' to get a string result
			filetext = filetext.trim();

			self.redis.hset(self.key_usermeta(self.load.fromuser), self.passwordattr, filetext, 
				function(err, reply) {
					if (err) nextfolder(err);
					else {
						self.log('password set');
						nextfolder(null, foldername);
					}
				}
			);
			return;
		}
		else {	// not .password, we're done
			self.log('Skipping unhandled .file: ' + foldername);
			nextfolder(null, foldername);
			return;
		}
	}

	var files = fs.readdirSync(self.load.fromdirectory);
	self.dir(files);
	async.forEachSeries(files,
		function(filename, nextfile) {
			NoteSoup.loadfile(self.load.fromdirectory, filename, self.load.tofolder, 
				function(err, reply) {
					if (err) nextfile(err);
					else nextfile(null);
				});
		},
		function(err, reply) { 
			if (err) self.log('Loadfolder: ' + err); 
			else {
				self.log('Loadfolder complete.', reply);
				nextfolder(null);
			}
		}
	);
},

loaduser: function(user, next) {
	var self = this;
	self.load = {};
	var userpath = __dirname + '/templates/soupbase/' + user;
	var folders = fs.readdirSync(userpath);
	self.log('Loading user: ' + user);
	self.load.fromuser = user;
	self.dir(folders);
	async.forEachSeries(folders,
		function(foldername, nextfolder) {
			//if (!self.load) self.load = {};
			self.load.fromdirectory = userpath + '/' + foldername;
			self.load.tofolder = user + '/' + foldername;
			NoteSoup.loadfolder(foldername, function(err, reply) {
				if (err) nextfolder(err);
				else nextfolder(null, foldername);
			});
		},
		function(err, reply) {
			if (err) next(err);
			else {
				self.log('Loaduser complete.', reply);
				next(null);
			}
		}
	);
},


// pipeline for initdb

getsystempassword: function(next) {
	var self = NoteSoup;
	
	// if the system password was passed in, set it
	if (process.env.soup_password !== undefined) {
		self.log('Setting system password.');
		self.savepasswordhash(
			self.systemuser,
			crypto.createHash('sha1').update(process.env.soup_password).digest('hex'),
			next);
		return;
	}

	// Don't try to get the system password if we have no console (Heroku, for example)
	if (self.argv.noconsole) {
		next(null);
		return;
	}

	var i = rl.createInterface(process.stdin, process.stdout, null);
	i.question('Enter a password for the "system" user:', function(password) {
		i.question('Enter it again:', function(password2) {
			if (password != password2) {
				self.log('Passwords do not match.  Please try again.');
				process.exit(1);
			}

			var passwordhash = crypto.createHash('sha1').update(password).digest('hex');
	
			self.log('Password hash: ' + passwordhash);
			self.save_password_hash(self.systemuser, passwordhash, 
				function(err, reply) {
	
					// per recipe from nodejs readline doc
					i.close();
					process.stdin.destroy();
					next(err);
				}
			);

		});
	});
},

setdbcreated: function(next) {
	var self = NoteSoup;
	var now = new Date();
	self.redis.set(self.key_dbcreated(), now, function(err, worked) {
		if (err) next(err);
		else next(null);
	});
},

loadsystemuser: function(next) { NoteSoup.loaduser('system', next); },
loadguestuser: function(next) { NoteSoup.loaduser('guest', next); },

key_dbcreated: function() { return 'stats/db_created'; },

initdatabase: function() {
	var self = this;
	self.log('Checking for database...');
	self.redis.get(self.key_dbcreated(), function(err, created) {
		if (err) {
			self.log('Init: Error reading database.  Is redis running?');
			process.exit(1);
		}
		else if (created) self.log('Using database created ' + created);
		else {
			self.log('Initializing database.');
			async.series([
					self.loadsystemuser,
					self.loadguestuser,
					self.getsystempassword,
					self.setdbcreated
				], 
				function(err, reply) {
					if (err) self.log(err);
					else self.log('Database initialization complete.');
				}
			);
		}
	});
}


};	// NoteSoup = {...};

module.exports = NoteSoup;
